// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: organizers.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrganizer = `-- name: CreateOrganizer :one
INSERT INTO organizers (
    id,
    organization_name,
    verification_status,
    rejection_reason,
    contacts,
    verified_at,
    verified_by
) VALUES (
    $1,
    $2,
    COALESCE($3, 'pending'),
    $4,
    $5,
    $6,
    $7
)
RETURNING id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
`

type CreateOrganizerParams struct {
	ID                 int64            `db:"id" json:"id"`
	OrganizationName   string           `db:"organization_name" json:"organization_name"`
	VerificationStatus interface{}      `db:"verification_status" json:"verification_status"`
	RejectionReason    pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	Contacts           pgtype.Text      `db:"contacts" json:"contacts"`
	VerifiedAt         pgtype.Timestamp `db:"verified_at" json:"verified_at"`
	VerifiedBy         pgtype.Int8      `db:"verified_by" json:"verified_by"`
}

func (q *Queries) CreateOrganizer(ctx context.Context, arg CreateOrganizerParams) (Organizer, error) {
	row := q.db.QueryRow(ctx, createOrganizer,
		arg.ID,
		arg.OrganizationName,
		arg.VerificationStatus,
		arg.RejectionReason,
		arg.Contacts,
		arg.VerifiedAt,
		arg.VerifiedBy,
	)
	var i Organizer
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrganizer = `-- name: DeleteOrganizer :exec
DELETE FROM organizers
WHERE id = $1
`

func (q *Queries) DeleteOrganizer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrganizer, id)
	return err
}

const getOrganizer = `-- name: GetOrganizer :one
SELECT id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
FROM organizers
WHERE id = $1
`

func (q *Queries) GetOrganizer(ctx context.Context, id int64) (Organizer, error) {
	row := q.db.QueryRow(ctx, getOrganizer, id)
	var i Organizer
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizerWithUser = `-- name: GetOrganizerWithUser :one
SELECT o.id, o.organization_name, o.verification_status, o.rejection_reason, o.contacts, o.verified_at, o.verified_by, o.created_at, o.updated_at, u.username, u.name, u.role, u.state
FROM organizers o
JOIN users u ON u.id = o.id
WHERE o.id = $1
`

type GetOrganizerWithUserRow struct {
	ID                 int64            `db:"id" json:"id"`
	OrganizationName   string           `db:"organization_name" json:"organization_name"`
	VerificationStatus pgtype.Text      `db:"verification_status" json:"verification_status"`
	RejectionReason    pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	Contacts           pgtype.Text      `db:"contacts" json:"contacts"`
	VerifiedAt         pgtype.Timestamp `db:"verified_at" json:"verified_at"`
	VerifiedBy         pgtype.Int8      `db:"verified_by" json:"verified_by"`
	CreatedAt          pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Username           pgtype.Text      `db:"username" json:"username"`
	Name               string           `db:"name" json:"name"`
	Role               string           `db:"role" json:"role"`
	State              string           `db:"state" json:"state"`
}

func (q *Queries) GetOrganizerWithUser(ctx context.Context, id int64) (GetOrganizerWithUserRow, error) {
	row := q.db.QueryRow(ctx, getOrganizerWithUser, id)
	var i GetOrganizerWithUserRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
	)
	return i, err
}

const listOrganizers = `-- name: ListOrganizers :many
SELECT id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
FROM organizers
ORDER BY created_at DESC
LIMIT $2::int
OFFSET $1::int
`

type ListOrganizersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListOrganizers(ctx context.Context, arg ListOrganizersParams) ([]Organizer, error) {
	rows, err := q.db.Query(ctx, listOrganizers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organizer
	for rows.Next() {
		var i Organizer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationName,
			&i.VerificationStatus,
			&i.RejectionReason,
			&i.Contacts,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizersByStatus = `-- name: ListOrganizersByStatus :many
SELECT id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
FROM organizers
WHERE verification_status = $1
ORDER BY updated_at DESC
LIMIT $3::int
OFFSET $2::int
`

type ListOrganizersByStatusParams struct {
	Status pgtype.Text `db:"status" json:"status"`
	Offset int32       `db:"offset" json:"offset"`
	Limit  int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListOrganizersByStatus(ctx context.Context, arg ListOrganizersByStatusParams) ([]Organizer, error) {
	rows, err := q.db.Query(ctx, listOrganizersByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organizer
	for rows.Next() {
		var i Organizer
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationName,
			&i.VerificationStatus,
			&i.RejectionReason,
			&i.Contacts,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOrganizersWithUsers = `-- name: ListPendingOrganizersWithUsers :many
SELECT o.id, o.organization_name, o.verification_status, o.rejection_reason, o.contacts, o.verified_at, o.verified_by, o.created_at, o.updated_at, u.username, u.name, u.role, u.state
FROM organizers o
JOIN users u ON u.id = o.id
WHERE o.verification_status = 'pending'
ORDER BY o.created_at ASC
LIMIT $2::int
OFFSET $1::int
`

type ListPendingOrganizersWithUsersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListPendingOrganizersWithUsersRow struct {
	ID                 int64            `db:"id" json:"id"`
	OrganizationName   string           `db:"organization_name" json:"organization_name"`
	VerificationStatus pgtype.Text      `db:"verification_status" json:"verification_status"`
	RejectionReason    pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	Contacts           pgtype.Text      `db:"contacts" json:"contacts"`
	VerifiedAt         pgtype.Timestamp `db:"verified_at" json:"verified_at"`
	VerifiedBy         pgtype.Int8      `db:"verified_by" json:"verified_by"`
	CreatedAt          pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Username           pgtype.Text      `db:"username" json:"username"`
	Name               string           `db:"name" json:"name"`
	Role               string           `db:"role" json:"role"`
	State              string           `db:"state" json:"state"`
}

func (q *Queries) ListPendingOrganizersWithUsers(ctx context.Context, arg ListPendingOrganizersWithUsersParams) ([]ListPendingOrganizersWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listPendingOrganizersWithUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingOrganizersWithUsersRow
	for rows.Next() {
		var i ListPendingOrganizersWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationName,
			&i.VerificationStatus,
			&i.RejectionReason,
			&i.Contacts,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOrganizerVerification = `-- name: SetOrganizerVerification :one
UPDATE organizers
SET
    verification_status = $1,
    rejection_reason = $2,
    verified_at = $3,
    verified_by = $4,
    updated_at = NOW()
WHERE id = $5
RETURNING id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
`

type SetOrganizerVerificationParams struct {
	VerificationStatus pgtype.Text      `db:"verification_status" json:"verification_status"`
	RejectionReason    pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	VerifiedAt         pgtype.Timestamp `db:"verified_at" json:"verified_at"`
	VerifiedBy         pgtype.Int8      `db:"verified_by" json:"verified_by"`
	ID                 int64            `db:"id" json:"id"`
}

func (q *Queries) SetOrganizerVerification(ctx context.Context, arg SetOrganizerVerificationParams) (Organizer, error) {
	row := q.db.QueryRow(ctx, setOrganizerVerification,
		arg.VerificationStatus,
		arg.RejectionReason,
		arg.VerifiedAt,
		arg.VerifiedBy,
		arg.ID,
	)
	var i Organizer
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrganizerProfile = `-- name: UpdateOrganizerProfile :one
UPDATE organizers
SET
    organization_name = $1,
    contacts = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
`

type UpdateOrganizerProfileParams struct {
	OrganizationName string      `db:"organization_name" json:"organization_name"`
	Contacts         pgtype.Text `db:"contacts" json:"contacts"`
	ID               int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateOrganizerProfile(ctx context.Context, arg UpdateOrganizerProfileParams) (Organizer, error) {
	row := q.db.QueryRow(ctx, updateOrganizerProfile, arg.OrganizationName, arg.Contacts, arg.ID)
	var i Organizer
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertOrganizer = `-- name: UpsertOrganizer :one
INSERT INTO organizers (
    id,
    organization_name,
    verification_status,
    rejection_reason,
    contacts,
    verified_at,
    verified_by
) VALUES (
    $1,
    $2,
    COALESCE($3, 'pending'),
    $4,
    $5,
    $6,
    $7
)
ON CONFLICT (id) DO UPDATE
SET
    organization_name = EXCLUDED.organization_name,
    verification_status = EXCLUDED.verification_status,
    rejection_reason = EXCLUDED.rejection_reason,
    contacts = EXCLUDED.contacts,
    verified_at = EXCLUDED.verified_at,
    verified_by = EXCLUDED.verified_by,
    updated_at = NOW()
RETURNING id, organization_name, verification_status, rejection_reason, contacts, verified_at, verified_by, created_at, updated_at
`

type UpsertOrganizerParams struct {
	ID                 int64            `db:"id" json:"id"`
	OrganizationName   string           `db:"organization_name" json:"organization_name"`
	VerificationStatus interface{}      `db:"verification_status" json:"verification_status"`
	RejectionReason    pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	Contacts           pgtype.Text      `db:"contacts" json:"contacts"`
	VerifiedAt         pgtype.Timestamp `db:"verified_at" json:"verified_at"`
	VerifiedBy         pgtype.Int8      `db:"verified_by" json:"verified_by"`
}

func (q *Queries) UpsertOrganizer(ctx context.Context, arg UpsertOrganizerParams) (Organizer, error) {
	row := q.db.QueryRow(ctx, upsertOrganizer,
		arg.ID,
		arg.OrganizationName,
		arg.VerificationStatus,
		arg.RejectionReason,
		arg.Contacts,
		arg.VerifiedAt,
		arg.VerifiedBy,
	)
	var i Organizer
	err := row.Scan(
		&i.ID,
		&i.OrganizationName,
		&i.VerificationStatus,
		&i.RejectionReason,
		&i.Contacts,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
