// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event_participants.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEventParticipant = `-- name: AddEventParticipant :one
INSERT INTO event_participants (
    event_id,
    volunteer_id,
    application_id,
    joined_chat_at
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, NOW())
)
RETURNING id, event_id, volunteer_id, application_id, joined_chat_at
`

type AddEventParticipantParams struct {
	EventID       pgtype.Int4 `db:"event_id" json:"event_id"`
	VolunteerID   pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	ApplicationID pgtype.Int4 `db:"application_id" json:"application_id"`
	JoinedChatAt  interface{} `db:"joined_chat_at" json:"joined_chat_at"`
}

func (q *Queries) AddEventParticipant(ctx context.Context, arg AddEventParticipantParams) (EventParticipant, error) {
	row := q.db.QueryRow(ctx, addEventParticipant,
		arg.EventID,
		arg.VolunteerID,
		arg.ApplicationID,
		arg.JoinedChatAt,
	)
	var i EventParticipant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.ApplicationID,
		&i.JoinedChatAt,
	)
	return i, err
}

const countParticipantsForEvent = `-- name: CountParticipantsForEvent :one
SELECT COUNT(*) AS count
FROM event_participants
WHERE event_id = $1
`

func (q *Queries) CountParticipantsForEvent(ctx context.Context, eventID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countParticipantsForEvent, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteParticipantsByEvent = `-- name: DeleteParticipantsByEvent :exec
DELETE FROM event_participants
WHERE event_id = $1
`

func (q *Queries) DeleteParticipantsByEvent(ctx context.Context, eventID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteParticipantsByEvent, eventID)
	return err
}

const getEventParticipant = `-- name: GetEventParticipant :one
SELECT id, event_id, volunteer_id, application_id, joined_chat_at
FROM event_participants
WHERE event_id = $1
  AND volunteer_id = $2
`

type GetEventParticipantParams struct {
	EventID     pgtype.Int4 `db:"event_id" json:"event_id"`
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
}

func (q *Queries) GetEventParticipant(ctx context.Context, arg GetEventParticipantParams) (EventParticipant, error) {
	row := q.db.QueryRow(ctx, getEventParticipant, arg.EventID, arg.VolunteerID)
	var i EventParticipant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.ApplicationID,
		&i.JoinedChatAt,
	)
	return i, err
}

const listEventParticipants = `-- name: ListEventParticipants :many
SELECT id, event_id, volunteer_id, application_id, joined_chat_at
FROM event_participants
WHERE event_id = $1
ORDER BY joined_chat_at DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventParticipantsParams struct {
	EventID pgtype.Int4 `db:"event_id" json:"event_id"`
	Offset  int32       `db:"offset" json:"offset"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListEventParticipants(ctx context.Context, arg ListEventParticipantsParams) ([]EventParticipant, error) {
	rows, err := q.db.Query(ctx, listEventParticipants, arg.EventID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventParticipant
	for rows.Next() {
		var i EventParticipant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.ApplicationID,
			&i.JoinedChatAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventParticipantsWithUsers = `-- name: ListEventParticipantsWithUsers :many
SELECT ep.id, ep.event_id, ep.volunteer_id, ep.application_id, ep.joined_chat_at, u.username, u.name, u.state
FROM event_participants ep
JOIN users u ON u.id = ep.volunteer_id
WHERE ep.event_id = $1
ORDER BY ep.joined_chat_at DESC, ep.id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventParticipantsWithUsersParams struct {
	EventID pgtype.Int4 `db:"event_id" json:"event_id"`
	Offset  int32       `db:"offset" json:"offset"`
	Limit   int32       `db:"limit" json:"limit"`
}

type ListEventParticipantsWithUsersRow struct {
	ID            int32            `db:"id" json:"id"`
	EventID       pgtype.Int4      `db:"event_id" json:"event_id"`
	VolunteerID   pgtype.Int8      `db:"volunteer_id" json:"volunteer_id"`
	ApplicationID pgtype.Int4      `db:"application_id" json:"application_id"`
	JoinedChatAt  pgtype.Timestamp `db:"joined_chat_at" json:"joined_chat_at"`
	Username      pgtype.Text      `db:"username" json:"username"`
	Name          string           `db:"name" json:"name"`
	State         string           `db:"state" json:"state"`
}

func (q *Queries) ListEventParticipantsWithUsers(ctx context.Context, arg ListEventParticipantsWithUsersParams) ([]ListEventParticipantsWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listEventParticipantsWithUsers, arg.EventID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventParticipantsWithUsersRow
	for rows.Next() {
		var i ListEventParticipantsWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.ApplicationID,
			&i.JoinedChatAt,
			&i.Username,
			&i.Name,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParticipantEvents = `-- name: ListParticipantEvents :many
SELECT ep.id, ep.event_id, ep.volunteer_id, ep.application_id, ep.joined_chat_at
FROM event_participants ep
WHERE ep.volunteer_id = $1
ORDER BY ep.joined_chat_at DESC, ep.id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListParticipantEventsParams struct {
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListParticipantEvents(ctx context.Context, arg ListParticipantEventsParams) ([]EventParticipant, error) {
	rows, err := q.db.Query(ctx, listParticipantEvents, arg.VolunteerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventParticipant
	for rows.Next() {
		var i EventParticipant
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.ApplicationID,
			&i.JoinedChatAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEventParticipant = `-- name: RemoveEventParticipant :exec
DELETE FROM event_participants
WHERE event_id = $1
  AND volunteer_id = $2
`

type RemoveEventParticipantParams struct {
	EventID     pgtype.Int4 `db:"event_id" json:"event_id"`
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
}

func (q *Queries) RemoveEventParticipant(ctx context.Context, arg RemoveEventParticipantParams) error {
	_, err := q.db.Exec(ctx, removeEventParticipant, arg.EventID, arg.VolunteerID)
	return err
}
