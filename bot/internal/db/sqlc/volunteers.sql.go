// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: volunteers.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVolunteer = `-- name: CreateVolunteer :one
INSERT INTO volunteers (
    id,
    about,
    search_radius,
    category_ids
) VALUES (
    $1,
    $2,
    COALESCE($3, 10),
    $4
)
RETURNING id, about, search_radius, category_ids
`

type CreateVolunteerParams struct {
	ID           int64       `db:"id" json:"id"`
	About        pgtype.Text `db:"about" json:"about"`
	SearchRadius interface{} `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32     `db:"category_ids" json:"category_ids"`
}

func (q *Queries) CreateVolunteer(ctx context.Context, arg CreateVolunteerParams) (Volunteer, error) {
	row := q.db.QueryRow(ctx, createVolunteer,
		arg.ID,
		arg.About,
		arg.SearchRadius,
		arg.CategoryIds,
	)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}

const deleteVolunteer = `-- name: DeleteVolunteer :exec
DELETE FROM volunteers
WHERE id = $1
`

func (q *Queries) DeleteVolunteer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVolunteer, id)
	return err
}

const getVolunteer = `-- name: GetVolunteer :one
SELECT id, about, search_radius, category_ids
FROM volunteers
WHERE id = $1
`

func (q *Queries) GetVolunteer(ctx context.Context, id int64) (Volunteer, error) {
	row := q.db.QueryRow(ctx, getVolunteer, id)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}

const getVolunteerWithUser = `-- name: GetVolunteerWithUser :one
SELECT v.id, v.about, v.search_radius, v.category_ids, u.username, u.name, u.role, u.state, u.location_lat, u.location_lon
FROM volunteers v
JOIN users u ON u.id = v.id
WHERE v.id = $1
`

type GetVolunteerWithUserRow struct {
	ID           int64          `db:"id" json:"id"`
	About        pgtype.Text    `db:"about" json:"about"`
	SearchRadius pgtype.Int4    `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32        `db:"category_ids" json:"category_ids"`
	Username     pgtype.Text    `db:"username" json:"username"`
	Name         string         `db:"name" json:"name"`
	Role         string         `db:"role" json:"role"`
	State        string         `db:"state" json:"state"`
	LocationLat  pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon  pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) GetVolunteerWithUser(ctx context.Context, id int64) (GetVolunteerWithUserRow, error) {
	row := q.db.QueryRow(ctx, getVolunteerWithUser, id)
	var i GetVolunteerWithUserRow
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const listVolunteers = `-- name: ListVolunteers :many
SELECT id, about, search_radius, category_ids
FROM volunteers
ORDER BY id
LIMIT $2::int
OFFSET $1::int
`

type ListVolunteersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListVolunteers(ctx context.Context, arg ListVolunteersParams) ([]Volunteer, error) {
	rows, err := q.db.Query(ctx, listVolunteers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Volunteer
	for rows.Next() {
		var i Volunteer
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolunteersByCategory = `-- name: ListVolunteersByCategory :many
SELECT id, about, search_radius, category_ids
FROM volunteers
WHERE category_ids && $1
ORDER BY id
LIMIT $3::int
OFFSET $2::int
`

type ListVolunteersByCategoryParams struct {
	CategoryIds []int32 `db:"category_ids" json:"category_ids"`
	Offset      int32   `db:"offset" json:"offset"`
	Limit       int32   `db:"limit" json:"limit"`
}

func (q *Queries) ListVolunteersByCategory(ctx context.Context, arg ListVolunteersByCategoryParams) ([]Volunteer, error) {
	rows, err := q.db.Query(ctx, listVolunteersByCategory, arg.CategoryIds, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Volunteer
	for rows.Next() {
		var i Volunteer
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolunteersByCategoryWithUsers = `-- name: ListVolunteersByCategoryWithUsers :many
SELECT v.id, v.about, v.search_radius, v.category_ids, u.username, u.name, u.role, u.state, u.location_lat, u.location_lon
FROM volunteers v
JOIN users u ON u.id = v.id
WHERE category_ids && $1
ORDER BY u.updated_at DESC
LIMIT $3::int
OFFSET $2::int
`

type ListVolunteersByCategoryWithUsersParams struct {
	CategoryIds []int32 `db:"category_ids" json:"category_ids"`
	Offset      int32   `db:"offset" json:"offset"`
	Limit       int32   `db:"limit" json:"limit"`
}

type ListVolunteersByCategoryWithUsersRow struct {
	ID           int64          `db:"id" json:"id"`
	About        pgtype.Text    `db:"about" json:"about"`
	SearchRadius pgtype.Int4    `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32        `db:"category_ids" json:"category_ids"`
	Username     pgtype.Text    `db:"username" json:"username"`
	Name         string         `db:"name" json:"name"`
	Role         string         `db:"role" json:"role"`
	State        string         `db:"state" json:"state"`
	LocationLat  pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon  pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) ListVolunteersByCategoryWithUsers(ctx context.Context, arg ListVolunteersByCategoryWithUsersParams) ([]ListVolunteersByCategoryWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listVolunteersByCategoryWithUsers, arg.CategoryIds, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVolunteersByCategoryWithUsersRow
	for rows.Next() {
		var i ListVolunteersByCategoryWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolunteersByIDs = `-- name: ListVolunteersByIDs :many
SELECT id, about, search_radius, category_ids
FROM volunteers
WHERE id = ANY($1::bigint[])
ORDER BY id
`

func (q *Queries) ListVolunteersByIDs(ctx context.Context, ids []int64) ([]Volunteer, error) {
	rows, err := q.db.Query(ctx, listVolunteersByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Volunteer
	for rows.Next() {
		var i Volunteer
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolunteersNearLocation = `-- name: ListVolunteersNearLocation :many
SELECT v.id, v.about, v.search_radius, v.category_ids, u.username, u.name, u.role, u.state, u.location_lat, u.location_lon
FROM volunteers v
JOIN users u ON u.id = v.id
WHERE u.is_blocked = FALSE
  AND u.location_lat IS NOT NULL
  AND u.location_lon IS NOT NULL
  AND ABS(u.location_lat - $1) <= $2
  AND ABS(u.location_lon - $3) <= $4
  AND (v.search_radius IS NULL OR v.search_radius >= $5)
ORDER BY POWER(u.location_lat - $1, 2) + POWER(u.location_lon - $3, 2)
LIMIT $7::int
OFFSET $6::int
`

type ListVolunteersNearLocationParams struct {
	TargetLat      pgtype.Numeric `db:"target_lat" json:"target_lat"`
	LatDelta       pgtype.Numeric `db:"lat_delta" json:"lat_delta"`
	TargetLon      pgtype.Numeric `db:"target_lon" json:"target_lon"`
	LonDelta       pgtype.Numeric `db:"lon_delta" json:"lon_delta"`
	RequiredRadius pgtype.Int4    `db:"required_radius" json:"required_radius"`
	Offset         int32          `db:"offset" json:"offset"`
	Limit          int32          `db:"limit" json:"limit"`
}

type ListVolunteersNearLocationRow struct {
	ID           int64          `db:"id" json:"id"`
	About        pgtype.Text    `db:"about" json:"about"`
	SearchRadius pgtype.Int4    `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32        `db:"category_ids" json:"category_ids"`
	Username     pgtype.Text    `db:"username" json:"username"`
	Name         string         `db:"name" json:"name"`
	Role         string         `db:"role" json:"role"`
	State        string         `db:"state" json:"state"`
	LocationLat  pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon  pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) ListVolunteersNearLocation(ctx context.Context, arg ListVolunteersNearLocationParams) ([]ListVolunteersNearLocationRow, error) {
	rows, err := q.db.Query(ctx, listVolunteersNearLocation,
		arg.TargetLat,
		arg.LatDelta,
		arg.TargetLon,
		arg.LonDelta,
		arg.RequiredRadius,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVolunteersNearLocationRow
	for rows.Next() {
		var i ListVolunteersNearLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolunteersWithUsers = `-- name: ListVolunteersWithUsers :many
SELECT v.id, v.about, v.search_radius, v.category_ids, u.username, u.name, u.role, u.state, u.location_lat, u.location_lon
FROM volunteers v
JOIN users u ON u.id = v.id
ORDER BY u.updated_at DESC
LIMIT $2::int
OFFSET $1::int
`

type ListVolunteersWithUsersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListVolunteersWithUsersRow struct {
	ID           int64          `db:"id" json:"id"`
	About        pgtype.Text    `db:"about" json:"about"`
	SearchRadius pgtype.Int4    `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32        `db:"category_ids" json:"category_ids"`
	Username     pgtype.Text    `db:"username" json:"username"`
	Name         string         `db:"name" json:"name"`
	Role         string         `db:"role" json:"role"`
	State        string         `db:"state" json:"state"`
	LocationLat  pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon  pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) ListVolunteersWithUsers(ctx context.Context, arg ListVolunteersWithUsersParams) ([]ListVolunteersWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listVolunteersWithUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVolunteersWithUsersRow
	for rows.Next() {
		var i ListVolunteersWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.About,
			&i.SearchRadius,
			&i.CategoryIds,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVolunteerCategories = `-- name: UpdateVolunteerCategories :one
UPDATE volunteers
SET
    category_ids = $1
WHERE id = $2
RETURNING id, about, search_radius, category_ids
`

type UpdateVolunteerCategoriesParams struct {
	CategoryIds []int32 `db:"category_ids" json:"category_ids"`
	ID          int64   `db:"id" json:"id"`
}

func (q *Queries) UpdateVolunteerCategories(ctx context.Context, arg UpdateVolunteerCategoriesParams) (Volunteer, error) {
	row := q.db.QueryRow(ctx, updateVolunteerCategories, arg.CategoryIds, arg.ID)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}

const updateVolunteerProfile = `-- name: UpdateVolunteerProfile :one
UPDATE volunteers
SET
    about = $1,
    search_radius = $2
WHERE id = $3
RETURNING id, about, search_radius, category_ids
`

type UpdateVolunteerProfileParams struct {
	About        pgtype.Text `db:"about" json:"about"`
	SearchRadius pgtype.Int4 `db:"search_radius" json:"search_radius"`
	ID           int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateVolunteerProfile(ctx context.Context, arg UpdateVolunteerProfileParams) (Volunteer, error) {
	row := q.db.QueryRow(ctx, updateVolunteerProfile, arg.About, arg.SearchRadius, arg.ID)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}

const updateVolunteerSearchRadius = `-- name: UpdateVolunteerSearchRadius :one
UPDATE volunteers
SET
    search_radius = $1
WHERE id = $2
RETURNING id, about, search_radius, category_ids
`

type UpdateVolunteerSearchRadiusParams struct {
	SearchRadius pgtype.Int4 `db:"search_radius" json:"search_radius"`
	ID           int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateVolunteerSearchRadius(ctx context.Context, arg UpdateVolunteerSearchRadiusParams) (Volunteer, error) {
	row := q.db.QueryRow(ctx, updateVolunteerSearchRadius, arg.SearchRadius, arg.ID)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}

const upsertVolunteer = `-- name: UpsertVolunteer :one
INSERT INTO volunteers (
    id,
    about,
    search_radius,
    category_ids
) VALUES (
    $1,
    $2,
    COALESCE($3, 10),
    $4
)
ON CONFLICT (id) DO UPDATE
SET
    about = EXCLUDED.about,
    search_radius = EXCLUDED.search_radius,
    category_ids = EXCLUDED.category_ids
RETURNING id, about, search_radius, category_ids
`

type UpsertVolunteerParams struct {
	ID           int64       `db:"id" json:"id"`
	About        pgtype.Text `db:"about" json:"about"`
	SearchRadius interface{} `db:"search_radius" json:"search_radius"`
	CategoryIds  []int32     `db:"category_ids" json:"category_ids"`
}

func (q *Queries) UpsertVolunteer(ctx context.Context, arg UpsertVolunteerParams) (Volunteer, error) {
	row := q.db.QueryRow(ctx, upsertVolunteer,
		arg.ID,
		arg.About,
		arg.SearchRadius,
		arg.CategoryIds,
	)
	var i Volunteer
	err := row.Scan(
		&i.ID,
		&i.About,
		&i.SearchRadius,
		&i.CategoryIds,
	)
	return i, err
}
