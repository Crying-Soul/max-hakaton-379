// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelEvent = `-- name: CancelEvent :one
UPDATE events
SET
    status = 'cancelled',
    cancelled_reason = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
`

type CancelEventParams struct {
	Reason pgtype.Text `db:"reason" json:"reason"`
	ID     int32       `db:"id" json:"id"`
}

func (q *Queries) CancelEvent(ctx context.Context, arg CancelEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, cancelEvent, arg.Reason, arg.ID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeEvent = `-- name: CompleteEvent :one
UPDATE events
SET
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
`

func (q *Queries) CompleteEvent(ctx context.Context, id int32) (Event, error) {
	row := q.db.QueryRow(ctx, completeEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAvailableEventsForVolunteer = `-- name: CountAvailableEventsForVolunteer :one
SELECT COUNT(*)
FROM events e
WHERE e.status = 'open'
  AND NOT EXISTS (
    SELECT 1
    FROM volunteer_applications va
    WHERE va.event_id = e.id
      AND va.volunteer_id = $1
  )
  AND NOT EXISTS (
    SELECT 1
    FROM event_participants ep
    WHERE ep.event_id = e.id
      AND ep.volunteer_id = $1
  )
`

func (q *Queries) CountAvailableEventsForVolunteer(ctx context.Context, volunteerID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableEventsForVolunteer, volunteerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM events
`

func (q *Queries) CountEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    title,
    description,
    chat,
    date,
    duration_hours,
    location,
    location_lat,
    location_lon,
    category_id,
    organizer_id,
    contacts,
    max_volunteers,
    current_volunteers,
    status,
    cancelled_reason,
    completed_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    COALESCE($13, 0),
    COALESCE($14, 'open'),
    $15,
    $16
)
RETURNING id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
`

type CreateEventParams struct {
	Title             string           `db:"title" json:"title"`
	Description       pgtype.Text      `db:"description" json:"description"`
	Chat              pgtype.Int8      `db:"chat" json:"chat"`
	Date              pgtype.Timestamp `db:"date" json:"date"`
	DurationHours     pgtype.Int4      `db:"duration_hours" json:"duration_hours"`
	Location          string           `db:"location" json:"location"`
	LocationLat       pgtype.Numeric   `db:"location_lat" json:"location_lat"`
	LocationLon       pgtype.Numeric   `db:"location_lon" json:"location_lon"`
	CategoryID        pgtype.Int4      `db:"category_id" json:"category_id"`
	OrganizerID       pgtype.Int8      `db:"organizer_id" json:"organizer_id"`
	Contacts          pgtype.Text      `db:"contacts" json:"contacts"`
	MaxVolunteers     int32            `db:"max_volunteers" json:"max_volunteers"`
	CurrentVolunteers interface{}      `db:"current_volunteers" json:"current_volunteers"`
	Status            interface{}      `db:"status" json:"status"`
	CancelledReason   pgtype.Text      `db:"cancelled_reason" json:"cancelled_reason"`
	CompletedAt       pgtype.Timestamp `db:"completed_at" json:"completed_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.Chat,
		arg.Date,
		arg.DurationHours,
		arg.Location,
		arg.LocationLat,
		arg.LocationLon,
		arg.CategoryID,
		arg.OrganizerID,
		arg.Contacts,
		arg.MaxVolunteers,
		arg.CurrentVolunteers,
		arg.Status,
		arg.CancelledReason,
		arg.CompletedAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id int32) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventWithOrganizer = `-- name: GetEventWithOrganizer :one
SELECT e.id, e.title, e.description, e.chat, e.date, e.duration_hours, e.location, e.location_lat, e.location_lon, e.category_id, e.organizer_id, e.contacts, e.max_volunteers, e.current_volunteers, e.status, e.cancelled_reason, e.completed_at, e.created_at, e.updated_at, o.organization_name, o.verification_status
FROM events e
JOIN organizers o ON o.id = e.organizer_id
WHERE e.id = $1
`

type GetEventWithOrganizerRow struct {
	ID                 int32            `db:"id" json:"id"`
	Title              string           `db:"title" json:"title"`
	Description        pgtype.Text      `db:"description" json:"description"`
	Chat               pgtype.Int8      `db:"chat" json:"chat"`
	Date               pgtype.Timestamp `db:"date" json:"date"`
	DurationHours      pgtype.Int4      `db:"duration_hours" json:"duration_hours"`
	Location           string           `db:"location" json:"location"`
	LocationLat        pgtype.Numeric   `db:"location_lat" json:"location_lat"`
	LocationLon        pgtype.Numeric   `db:"location_lon" json:"location_lon"`
	CategoryID         pgtype.Int4      `db:"category_id" json:"category_id"`
	OrganizerID        pgtype.Int8      `db:"organizer_id" json:"organizer_id"`
	Contacts           pgtype.Text      `db:"contacts" json:"contacts"`
	MaxVolunteers      int32            `db:"max_volunteers" json:"max_volunteers"`
	CurrentVolunteers  pgtype.Int4      `db:"current_volunteers" json:"current_volunteers"`
	Status             pgtype.Text      `db:"status" json:"status"`
	CancelledReason    pgtype.Text      `db:"cancelled_reason" json:"cancelled_reason"`
	CompletedAt        pgtype.Timestamp `db:"completed_at" json:"completed_at"`
	CreatedAt          pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	OrganizationName   string           `db:"organization_name" json:"organization_name"`
	VerificationStatus pgtype.Text      `db:"verification_status" json:"verification_status"`
}

func (q *Queries) GetEventWithOrganizer(ctx context.Context, id int32) (GetEventWithOrganizerRow, error) {
	row := q.db.QueryRow(ctx, getEventWithOrganizer, id)
	var i GetEventWithOrganizerRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationName,
		&i.VerificationStatus,
	)
	return i, err
}

const incrementEventVolunteers = `-- name: IncrementEventVolunteers :one
UPDATE events
SET
    current_volunteers = current_volunteers + $1,
    updated_at = NOW()
WHERE id = $2
RETURNING current_volunteers
`

type IncrementEventVolunteersParams struct {
	Delta pgtype.Int4 `db:"delta" json:"delta"`
	ID    int32       `db:"id" json:"id"`
}

func (q *Queries) IncrementEventVolunteers(ctx context.Context, arg IncrementEventVolunteersParams) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, incrementEventVolunteers, arg.Delta, arg.ID)
	var current_volunteers pgtype.Int4
	err := row.Scan(&current_volunteers)
	return current_volunteers, err
}

const listAvailableEventsForVolunteer = `-- name: ListAvailableEventsForVolunteer :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events e
WHERE e.status = 'open'
  AND NOT EXISTS (
    SELECT 1
    FROM volunteer_applications va
    WHERE va.event_id = e.id
      AND va.volunteer_id = $1
  )
  AND NOT EXISTS (
    SELECT 1
    FROM event_participants ep
    WHERE ep.event_id = e.id
      AND ep.volunteer_id = $1
  )
ORDER BY e.date DESC, e.id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListAvailableEventsForVolunteerParams struct {
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListAvailableEventsForVolunteer(ctx context.Context, arg ListAvailableEventsForVolunteerParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listAvailableEventsForVolunteer, arg.VolunteerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
ORDER BY date DESC, id DESC
LIMIT $2::int
OFFSET $1::int
`

type ListEventsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByCategory = `-- name: ListEventsByCategory :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE category_id = $1
ORDER BY date DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventsByCategoryParams struct {
	CategoryID pgtype.Int4 `db:"category_id" json:"category_id"`
	Offset     int32       `db:"offset" json:"offset"`
	Limit      int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsByCategory(ctx context.Context, arg ListEventsByCategoryParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsByCategory, arg.CategoryID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByOrganizer = `-- name: ListEventsByOrganizer :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE organizer_id = $1
ORDER BY date DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventsByOrganizerParams struct {
	OrganizerID pgtype.Int8 `db:"organizer_id" json:"organizer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsByOrganizer(ctx context.Context, arg ListEventsByOrganizerParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsByOrganizer, arg.OrganizerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByStatus = `-- name: ListEventsByStatus :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE status = $1
ORDER BY date DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventsByStatusParams struct {
	Status pgtype.Text `db:"status" json:"status"`
	Offset int32       `db:"offset" json:"offset"`
	Limit  int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsByStatus(ctx context.Context, arg ListEventsByStatusParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsForMap = `-- name: ListEventsForMap :many
WITH candidate AS (
    SELECT
        e.id,
        e.title,
        e.description,
        e.date,
        e.duration_hours,
        e.location,
        e.location_lat,
        e.location_lon,
        e.category_id,
        e.organizer_id,
        e.contacts,
        e.chat,
        e.max_volunteers,
        COALESCE(e.current_volunteers, 0) AS current_volunteers,
        e.status,
        e.cancelled_reason,
        e.completed_at,
        e.created_at,
        e.updated_at,
        c.name AS category_name,
        GREATEST(e.max_volunteers - COALESCE(e.current_volunteers, 0), 0)::int4 AS slots_left,
        CAST(6371 * acos(
            LEAST(
                1,
                GREATEST(
                    -1,
                    cos(radians($3)) * cos(radians(e.location_lat::float8)) *
                    cos(radians(e.location_lon::float8) - radians($4)) +
                    sin(radians($3)) * sin(radians(e.location_lat::float8))
                )
            )
        ) AS double precision) AS distance_km
    FROM events e
    LEFT JOIN categories c ON c.id = e.category_id
    WHERE e.status = 'open'
      AND e.location_lat IS NOT NULL
      AND e.location_lon IS NOT NULL
      AND (
            e.max_volunteers = 0 OR
            e.current_volunteers IS NULL OR
            e.current_volunteers < e.max_volunteers
      )
      AND (
        $5::int[] IS NULL OR
        e.category_id = ANY($5::int[])
      )
      AND CAST(6371 * acos(
            LEAST(
                1,
                GREATEST(
                    -1,
                    cos(radians($3)) * cos(radians(e.location_lat::float8)) *
                    cos(radians(e.location_lon::float8) - radians($4)) +
                    sin(radians($3)) * sin(radians(e.location_lat::float8))
                )
            )
    ) AS double precision) <= $6::double precision
)
SELECT
    id,
    title,
    description,
    date,
    duration_hours,
    location,
    location_lat,
    location_lon,
    category_id,
    organizer_id,
    contacts,
    chat,
    max_volunteers,
    current_volunteers,
    status,
    cancelled_reason,
    completed_at,
    created_at,
    updated_at,
    category_name,
    slots_left::int4 AS slots_left,
    distance_km::double precision AS distance_km
FROM candidate
ORDER BY distance_km ASC, date ASC
LIMIT $2::int
OFFSET $1::int
`

type ListEventsForMapParams struct {
	Offset      int32   `db:"offset" json:"offset"`
	Limit       int32   `db:"limit" json:"limit"`
	Lat         float64 `db:"lat" json:"lat"`
	Lon         float64 `db:"lon" json:"lon"`
	CategoryIds []int32 `db:"category_ids" json:"category_ids"`
	RadiusKm    float64 `db:"radius_km" json:"radius_km"`
}

type ListEventsForMapRow struct {
	ID                int32            `db:"id" json:"id"`
	Title             string           `db:"title" json:"title"`
	Description       pgtype.Text      `db:"description" json:"description"`
	Date              pgtype.Timestamp `db:"date" json:"date"`
	DurationHours     pgtype.Int4      `db:"duration_hours" json:"duration_hours"`
	Location          string           `db:"location" json:"location"`
	LocationLat       pgtype.Numeric   `db:"location_lat" json:"location_lat"`
	LocationLon       pgtype.Numeric   `db:"location_lon" json:"location_lon"`
	CategoryID        pgtype.Int4      `db:"category_id" json:"category_id"`
	OrganizerID       pgtype.Int8      `db:"organizer_id" json:"organizer_id"`
	Contacts          pgtype.Text      `db:"contacts" json:"contacts"`
	Chat              pgtype.Int8      `db:"chat" json:"chat"`
	MaxVolunteers     int32            `db:"max_volunteers" json:"max_volunteers"`
	CurrentVolunteers int32            `db:"current_volunteers" json:"current_volunteers"`
	Status            pgtype.Text      `db:"status" json:"status"`
	CancelledReason   pgtype.Text      `db:"cancelled_reason" json:"cancelled_reason"`
	CompletedAt       pgtype.Timestamp `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	CategoryName      pgtype.Text      `db:"category_name" json:"category_name"`
	SlotsLeft         int32            `db:"slots_left" json:"slots_left"`
	DistanceKm        float64          `db:"distance_km" json:"distance_km"`
}

func (q *Queries) ListEventsForMap(ctx context.Context, arg ListEventsForMapParams) ([]ListEventsForMapRow, error) {
	rows, err := q.db.Query(ctx, listEventsForMap,
		arg.Offset,
		arg.Limit,
		arg.Lat,
		arg.Lon,
		arg.CategoryIds,
		arg.RadiusKm,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsForMapRow
	for rows.Next() {
		var i ListEventsForMapRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.Chat,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.SlotsLeft,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsForMapByVolunteer = `-- name: ListEventsForMapByVolunteer :many
WITH user_apps AS (
    SELECT
        va.event_id,
        va.status
    FROM volunteer_applications va
    WHERE va.volunteer_id = $3
),
candidate AS (
    SELECT
        e.id,
        e.title,
        e.description,
        e.date,
        e.duration_hours,
        e.location,
        e.location_lat,
        e.location_lon,
        e.category_id,
        e.organizer_id,
        e.contacts,
        e.chat,
        e.max_volunteers,
        COALESCE(e.current_volunteers, 0) AS current_volunteers,
        e.status,
        e.cancelled_reason,
        e.completed_at,
        e.created_at,
        e.updated_at,
        c.name AS category_name,
        GREATEST(e.max_volunteers - COALESCE(e.current_volunteers, 0), 0)::int4 AS slots_left,
        CAST(6371 * acos(
            LEAST(
                1,
                GREATEST(
                    -1,
                    cos(radians($4)) * cos(radians(e.location_lat::float8)) *
                    cos(radians(e.location_lon::float8) - radians($5)) +
                    sin(radians($4)) * sin(radians(e.location_lat::float8))
                )
            )
        ) AS double precision) AS distance_km,
        ua.status AS application_status
    FROM events e
    JOIN user_apps ua ON ua.event_id = e.id
    LEFT JOIN categories c ON c.id = e.category_id
    WHERE e.location_lat IS NOT NULL
      AND e.location_lon IS NOT NULL
      AND (
        $6::int[] IS NULL OR
        e.category_id = ANY($6::int[])
      )
      AND CAST(6371 * acos(
            LEAST(
                1,
                GREATEST(
                    -1,
                    cos(radians($4)) * cos(radians(e.location_lat::float8)) *
                    cos(radians(e.location_lon::float8) - radians($5)) +
                    sin(radians($4)) * sin(radians(e.location_lat::float8))
                )
            )
    ) AS double precision) <= $7::double precision
)
SELECT
    id,
    title,
    description,
    date,
    duration_hours,
    location,
    location_lat,
    location_lon,
    category_id,
    organizer_id,
    contacts,
    chat,
    max_volunteers,
    current_volunteers,
    status,
    cancelled_reason,
    completed_at,
    created_at,
    updated_at,
    category_name,
    slots_left::int4 AS slots_left,
    distance_km::double precision AS distance_km,
    application_status
FROM candidate
ORDER BY distance_km ASC, date ASC
LIMIT $2::int
OFFSET $1::int
`

type ListEventsForMapByVolunteerParams struct {
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	Lat         float64     `db:"lat" json:"lat"`
	Lon         float64     `db:"lon" json:"lon"`
	CategoryIds []int32     `db:"category_ids" json:"category_ids"`
	RadiusKm    float64     `db:"radius_km" json:"radius_km"`
}

type ListEventsForMapByVolunteerRow struct {
	ID                int32            `db:"id" json:"id"`
	Title             string           `db:"title" json:"title"`
	Description       pgtype.Text      `db:"description" json:"description"`
	Date              pgtype.Timestamp `db:"date" json:"date"`
	DurationHours     pgtype.Int4      `db:"duration_hours" json:"duration_hours"`
	Location          string           `db:"location" json:"location"`
	LocationLat       pgtype.Numeric   `db:"location_lat" json:"location_lat"`
	LocationLon       pgtype.Numeric   `db:"location_lon" json:"location_lon"`
	CategoryID        pgtype.Int4      `db:"category_id" json:"category_id"`
	OrganizerID       pgtype.Int8      `db:"organizer_id" json:"organizer_id"`
	Contacts          pgtype.Text      `db:"contacts" json:"contacts"`
	Chat              pgtype.Int8      `db:"chat" json:"chat"`
	MaxVolunteers     int32            `db:"max_volunteers" json:"max_volunteers"`
	CurrentVolunteers int32            `db:"current_volunteers" json:"current_volunteers"`
	Status            pgtype.Text      `db:"status" json:"status"`
	CancelledReason   pgtype.Text      `db:"cancelled_reason" json:"cancelled_reason"`
	CompletedAt       pgtype.Timestamp `db:"completed_at" json:"completed_at"`
	CreatedAt         pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	CategoryName      pgtype.Text      `db:"category_name" json:"category_name"`
	SlotsLeft         int32            `db:"slots_left" json:"slots_left"`
	DistanceKm        float64          `db:"distance_km" json:"distance_km"`
	ApplicationStatus pgtype.Text      `db:"application_status" json:"application_status"`
}

func (q *Queries) ListEventsForMapByVolunteer(ctx context.Context, arg ListEventsForMapByVolunteerParams) ([]ListEventsForMapByVolunteerRow, error) {
	rows, err := q.db.Query(ctx, listEventsForMapByVolunteer,
		arg.Offset,
		arg.Limit,
		arg.VolunteerID,
		arg.Lat,
		arg.Lon,
		arg.CategoryIds,
		arg.RadiusKm,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventsForMapByVolunteerRow
	for rows.Next() {
		var i ListEventsForMapByVolunteerRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.Chat,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.SlotsLeft,
			&i.DistanceKm,
			&i.ApplicationStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsForVolunteer = `-- name: ListEventsForVolunteer :many
SELECT e.id, e.title, e.description, e.chat, e.date, e.duration_hours, e.location, e.location_lat, e.location_lon, e.category_id, e.organizer_id, e.contacts, e.max_volunteers, e.current_volunteers, e.status, e.cancelled_reason, e.completed_at, e.created_at, e.updated_at
FROM events e
JOIN event_participants ep ON ep.event_id = e.id
WHERE ep.volunteer_id = $1
ORDER BY e.date DESC, e.id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListEventsForVolunteerParams struct {
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsForVolunteer(ctx context.Context, arg ListEventsForVolunteerParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsForVolunteer, arg.VolunteerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsNearLocation = `-- name: ListEventsNearLocation :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE status = 'open'
  AND date >= $1
  AND ABS(location_lat - $2) <= $3
  AND ABS(location_lon - $4) <= $5
ORDER BY POWER(location_lat - $2, 2) + POWER(location_lon - $4, 2)
LIMIT $7::int
OFFSET $6::int
`

type ListEventsNearLocationParams struct {
	StartDate pgtype.Timestamp `db:"start_date" json:"start_date"`
	TargetLat pgtype.Numeric   `db:"target_lat" json:"target_lat"`
	LatDelta  pgtype.Numeric   `db:"lat_delta" json:"lat_delta"`
	TargetLon pgtype.Numeric   `db:"target_lon" json:"target_lon"`
	LonDelta  pgtype.Numeric   `db:"lon_delta" json:"lon_delta"`
	Offset    int32            `db:"offset" json:"offset"`
	Limit     int32            `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsNearLocation(ctx context.Context, arg ListEventsNearLocationParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsNearLocation,
		arg.StartDate,
		arg.TargetLat,
		arg.LatDelta,
		arg.TargetLon,
		arg.LonDelta,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsWithPendingApplications = `-- name: ListEventsWithPendingApplications :many
SELECT e.id, e.title, e.description, e.chat, e.date, e.duration_hours, e.location, e.location_lat, e.location_lon, e.category_id, e.organizer_id, e.contacts, e.max_volunteers, e.current_volunteers, e.status, e.cancelled_reason, e.completed_at, e.created_at, e.updated_at
FROM events e
WHERE EXISTS (
    SELECT 1
    FROM volunteer_applications va
    WHERE va.event_id = e.id
      AND va.status = 'pending'
)
ORDER BY e.updated_at DESC
LIMIT $2::int
OFFSET $1::int
`

type ListEventsWithPendingApplicationsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListEventsWithPendingApplications(ctx context.Context, arg ListEventsWithPendingApplicationsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEventsWithPendingApplications, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingEvents = `-- name: ListUpcomingEvents :many
SELECT id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
FROM events
WHERE status = 'open'
  AND date >= $1
ORDER BY date ASC, id ASC
LIMIT $3::int
OFFSET $2::int
`

type ListUpcomingEventsParams struct {
	StartDate pgtype.Timestamp `db:"start_date" json:"start_date"`
	Offset    int32            `db:"offset" json:"offset"`
	Limit     int32            `db:"limit" json:"limit"`
}

func (q *Queries) ListUpcomingEvents(ctx context.Context, arg ListUpcomingEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listUpcomingEvents, arg.StartDate, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Chat,
			&i.Date,
			&i.DurationHours,
			&i.Location,
			&i.LocationLat,
			&i.LocationLon,
			&i.CategoryID,
			&i.OrganizerID,
			&i.Contacts,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.Status,
			&i.CancelledReason,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEventVolunteerCounts = `-- name: SetEventVolunteerCounts :one
UPDATE events
SET
    current_volunteers = $1,
    max_volunteers = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING current_volunteers, max_volunteers
`

type SetEventVolunteerCountsParams struct {
	CurrentVolunteers pgtype.Int4 `db:"current_volunteers" json:"current_volunteers"`
	MaxVolunteers     int32       `db:"max_volunteers" json:"max_volunteers"`
	ID                int32       `db:"id" json:"id"`
}

type SetEventVolunteerCountsRow struct {
	CurrentVolunteers pgtype.Int4 `db:"current_volunteers" json:"current_volunteers"`
	MaxVolunteers     int32       `db:"max_volunteers" json:"max_volunteers"`
}

func (q *Queries) SetEventVolunteerCounts(ctx context.Context, arg SetEventVolunteerCountsParams) (SetEventVolunteerCountsRow, error) {
	row := q.db.QueryRow(ctx, setEventVolunteerCounts, arg.CurrentVolunteers, arg.MaxVolunteers, arg.ID)
	var i SetEventVolunteerCountsRow
	err := row.Scan(&i.CurrentVolunteers, &i.MaxVolunteers)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
    title = $1,
    description = $2,
    chat = $3,
    date = $4,
    duration_hours = $5,
    location = $6,
    location_lat = $7,
    location_lon = $8,
    category_id = $9,
    contacts = $10,
    max_volunteers = $11,
    updated_at = NOW()
WHERE id = $12
RETURNING id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
`

type UpdateEventParams struct {
	Title         string           `db:"title" json:"title"`
	Description   pgtype.Text      `db:"description" json:"description"`
	Chat          pgtype.Int8      `db:"chat" json:"chat"`
	Date          pgtype.Timestamp `db:"date" json:"date"`
	DurationHours pgtype.Int4      `db:"duration_hours" json:"duration_hours"`
	Location      string           `db:"location" json:"location"`
	LocationLat   pgtype.Numeric   `db:"location_lat" json:"location_lat"`
	LocationLon   pgtype.Numeric   `db:"location_lon" json:"location_lon"`
	CategoryID    pgtype.Int4      `db:"category_id" json:"category_id"`
	Contacts      pgtype.Text      `db:"contacts" json:"contacts"`
	MaxVolunteers int32            `db:"max_volunteers" json:"max_volunteers"`
	ID            int32            `db:"id" json:"id"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Title,
		arg.Description,
		arg.Chat,
		arg.Date,
		arg.DurationHours,
		arg.Location,
		arg.LocationLat,
		arg.LocationLon,
		arg.CategoryID,
		arg.Contacts,
		arg.MaxVolunteers,
		arg.ID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventStatus = `-- name: UpdateEventStatus :one
UPDATE events
SET
    status = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, title, description, chat, date, duration_hours, location, location_lat, location_lon, category_id, organizer_id, contacts, max_volunteers, current_volunteers, status, cancelled_reason, completed_at, created_at, updated_at
`

type UpdateEventStatusParams struct {
	Status pgtype.Text `db:"status" json:"status"`
	ID     int32       `db:"id" json:"id"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEventStatus, arg.Status, arg.ID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Chat,
		&i.Date,
		&i.DurationHours,
		&i.Location,
		&i.LocationLat,
		&i.LocationLon,
		&i.CategoryID,
		&i.OrganizerID,
		&i.Contacts,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.Status,
		&i.CancelledReason,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
