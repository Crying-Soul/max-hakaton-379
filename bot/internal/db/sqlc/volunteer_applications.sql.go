// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: volunteer_applications.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVolunteerApplication = `-- name: CreateVolunteerApplication :one
INSERT INTO volunteer_applications (
    event_id,
    volunteer_id,
    status,
    rejection_reason,
    reviewed_by,
    reviewed_at
) VALUES (
    $1,
    $2,
    COALESCE($3, 'pending'),
    $4,
    $5,
    $6
)
RETURNING id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
`

type CreateVolunteerApplicationParams struct {
	EventID         pgtype.Int4      `db:"event_id" json:"event_id"`
	VolunteerID     pgtype.Int8      `db:"volunteer_id" json:"volunteer_id"`
	Status          interface{}      `db:"status" json:"status"`
	RejectionReason pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	ReviewedBy      pgtype.Int8      `db:"reviewed_by" json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamp `db:"reviewed_at" json:"reviewed_at"`
}

func (q *Queries) CreateVolunteerApplication(ctx context.Context, arg CreateVolunteerApplicationParams) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, createVolunteerApplication,
		arg.EventID,
		arg.VolunteerID,
		arg.Status,
		arg.RejectionReason,
		arg.ReviewedBy,
		arg.ReviewedAt,
	)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const deleteVolunteerApplication = `-- name: DeleteVolunteerApplication :exec
DELETE FROM volunteer_applications
WHERE id = $1
`

func (q *Queries) DeleteVolunteerApplication(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVolunteerApplication, id)
	return err
}

const getVolunteerApplication = `-- name: GetVolunteerApplication :one
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE event_id = $1
  AND volunteer_id = $2
`

type GetVolunteerApplicationParams struct {
	EventID     pgtype.Int4 `db:"event_id" json:"event_id"`
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
}

func (q *Queries) GetVolunteerApplication(ctx context.Context, arg GetVolunteerApplicationParams) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, getVolunteerApplication, arg.EventID, arg.VolunteerID)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const getVolunteerApplicationByID = `-- name: GetVolunteerApplicationByID :one
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE id = $1
`

func (q *Queries) GetVolunteerApplicationByID(ctx context.Context, id int32) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, getVolunteerApplicationByID, id)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const listApplicationsByEvent = `-- name: ListApplicationsByEvent :many
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE event_id = $1
ORDER BY applied_at DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListApplicationsByEventParams struct {
	EventID pgtype.Int4 `db:"event_id" json:"event_id"`
	Offset  int32       `db:"offset" json:"offset"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListApplicationsByEvent(ctx context.Context, arg ListApplicationsByEventParams) ([]VolunteerApplication, error) {
	rows, err := q.db.Query(ctx, listApplicationsByEvent, arg.EventID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolunteerApplication
	for rows.Next() {
		var i VolunteerApplication
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.Status,
			&i.RejectionReason,
			&i.ReviewedBy,
			&i.AppliedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationsByStatus = `-- name: ListApplicationsByStatus :many
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE status = $1
ORDER BY applied_at DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListApplicationsByStatusParams struct {
	Status pgtype.Text `db:"status" json:"status"`
	Offset int32       `db:"offset" json:"offset"`
	Limit  int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListApplicationsByStatus(ctx context.Context, arg ListApplicationsByStatusParams) ([]VolunteerApplication, error) {
	rows, err := q.db.Query(ctx, listApplicationsByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolunteerApplication
	for rows.Next() {
		var i VolunteerApplication
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.Status,
			&i.RejectionReason,
			&i.ReviewedBy,
			&i.AppliedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationsByVolunteer = `-- name: ListApplicationsByVolunteer :many
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE volunteer_id = $1
ORDER BY applied_at DESC, id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListApplicationsByVolunteerParams struct {
	VolunteerID pgtype.Int8 `db:"volunteer_id" json:"volunteer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListApplicationsByVolunteer(ctx context.Context, arg ListApplicationsByVolunteerParams) ([]VolunteerApplication, error) {
	rows, err := q.db.Query(ctx, listApplicationsByVolunteer, arg.VolunteerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolunteerApplication
	for rows.Next() {
		var i VolunteerApplication
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.Status,
			&i.RejectionReason,
			&i.ReviewedBy,
			&i.AppliedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationsForOrganizer = `-- name: ListApplicationsForOrganizer :many
SELECT va.id, va.event_id, va.volunteer_id, va.status, va.rejection_reason, va.reviewed_by, va.applied_at, va.reviewed_at
FROM volunteer_applications va
JOIN events e ON e.id = va.event_id
WHERE e.organizer_id = $1
ORDER BY va.applied_at DESC, va.id DESC
LIMIT $3::int
OFFSET $2::int
`

type ListApplicationsForOrganizerParams struct {
	OrganizerID pgtype.Int8 `db:"organizer_id" json:"organizer_id"`
	Offset      int32       `db:"offset" json:"offset"`
	Limit       int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListApplicationsForOrganizer(ctx context.Context, arg ListApplicationsForOrganizerParams) ([]VolunteerApplication, error) {
	rows, err := q.db.Query(ctx, listApplicationsForOrganizer, arg.OrganizerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolunteerApplication
	for rows.Next() {
		var i VolunteerApplication
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.Status,
			&i.RejectionReason,
			&i.ReviewedBy,
			&i.AppliedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingApplicationsByEvent = `-- name: ListPendingApplicationsByEvent :many
SELECT id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
FROM volunteer_applications
WHERE event_id = $1
  AND status = 'pending'
ORDER BY applied_at ASC, id ASC
LIMIT $3::int
OFFSET $2::int
`

type ListPendingApplicationsByEventParams struct {
	EventID pgtype.Int4 `db:"event_id" json:"event_id"`
	Offset  int32       `db:"offset" json:"offset"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) ListPendingApplicationsByEvent(ctx context.Context, arg ListPendingApplicationsByEventParams) ([]VolunteerApplication, error) {
	rows, err := q.db.Query(ctx, listPendingApplicationsByEvent, arg.EventID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VolunteerApplication
	for rows.Next() {
		var i VolunteerApplication
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.VolunteerID,
			&i.Status,
			&i.RejectionReason,
			&i.ReviewedBy,
			&i.AppliedAt,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetVolunteerApplicationReview = `-- name: ResetVolunteerApplicationReview :one
UPDATE volunteer_applications
SET
    status = 'pending',
    rejection_reason = NULL,
    reviewed_by = NULL,
    reviewed_at = NULL
WHERE id = $1
RETURNING id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
`

func (q *Queries) ResetVolunteerApplicationReview(ctx context.Context, id int32) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, resetVolunteerApplicationReview, id)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const updateVolunteerApplicationStatus = `-- name: UpdateVolunteerApplicationStatus :one
UPDATE volunteer_applications
SET
    status = $1,
    rejection_reason = $2,
    reviewed_by = $3,
    reviewed_at = COALESCE($4, NOW())
WHERE id = $5
RETURNING id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
`

type UpdateVolunteerApplicationStatusParams struct {
	Status          pgtype.Text      `db:"status" json:"status"`
	RejectionReason pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	ReviewedBy      pgtype.Int8      `db:"reviewed_by" json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamp `db:"reviewed_at" json:"reviewed_at"`
	ID              int32            `db:"id" json:"id"`
}

func (q *Queries) UpdateVolunteerApplicationStatus(ctx context.Context, arg UpdateVolunteerApplicationStatusParams) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, updateVolunteerApplicationStatus,
		arg.Status,
		arg.RejectionReason,
		arg.ReviewedBy,
		arg.ReviewedAt,
		arg.ID,
	)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const upsertVolunteerApplication = `-- name: UpsertVolunteerApplication :one
INSERT INTO volunteer_applications (
    event_id,
    volunteer_id,
    status,
    rejection_reason,
    reviewed_by,
    reviewed_at
) VALUES (
    $1,
    $2,
    COALESCE($3, 'pending'),
    $4,
    $5,
    $6
)
ON CONFLICT (event_id, volunteer_id) DO UPDATE
SET
    status = EXCLUDED.status,
    rejection_reason = EXCLUDED.rejection_reason,
    reviewed_by = EXCLUDED.reviewed_by,
    reviewed_at = EXCLUDED.reviewed_at
RETURNING id, event_id, volunteer_id, status, rejection_reason, reviewed_by, applied_at, reviewed_at
`

type UpsertVolunteerApplicationParams struct {
	EventID         pgtype.Int4      `db:"event_id" json:"event_id"`
	VolunteerID     pgtype.Int8      `db:"volunteer_id" json:"volunteer_id"`
	Status          interface{}      `db:"status" json:"status"`
	RejectionReason pgtype.Text      `db:"rejection_reason" json:"rejection_reason"`
	ReviewedBy      pgtype.Int8      `db:"reviewed_by" json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamp `db:"reviewed_at" json:"reviewed_at"`
}

func (q *Queries) UpsertVolunteerApplication(ctx context.Context, arg UpsertVolunteerApplicationParams) (VolunteerApplication, error) {
	row := q.db.QueryRow(ctx, upsertVolunteerApplication,
		arg.EventID,
		arg.VolunteerID,
		arg.Status,
		arg.RejectionReason,
		arg.ReviewedBy,
		arg.ReviewedAt,
	)
	var i VolunteerApplication
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.VolunteerID,
		&i.Status,
		&i.RejectionReason,
		&i.ReviewedBy,
		&i.AppliedAt,
		&i.ReviewedAt,
	)
	return i, err
}
