// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blockUser = `-- name: BlockUser :exec
UPDATE users
SET
    is_blocked = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) BlockUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, blockUser, id)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id,
    username,
    name,
    role,
    state,
    is_blocked,
    location_lat,
    location_lon
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, false),
    $7,
    $8
)
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type CreateUserParams struct {
	ID          int64          `db:"id" json:"id"`
	Username    pgtype.Text    `db:"username" json:"username"`
	Name        string         `db:"name" json:"name"`
	Role        string         `db:"role" json:"role"`
	State       string         `db:"state" json:"state"`
	IsBlocked   interface{}    `db:"is_blocked" json:"is_blocked"`
	LocationLat pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.Name,
		arg.Role,
		arg.State,
		arg.IsBlocked,
		arg.LocationLat,
		arg.LocationLon,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const listBlockedUsers = `-- name: ListBlockedUsers :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE is_blocked = TRUE
ORDER BY updated_at DESC
LIMIT $2::int
OFFSET $1::int
`

type ListBlockedUsersParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListBlockedUsers(ctx context.Context, arg ListBlockedUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listBlockedUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByIDs = `-- name: ListUsersByIDs :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE id = ANY($1::bigint[])
ORDER BY updated_at DESC
`

func (q *Queries) ListUsersByIDs(ctx context.Context, ids []int64) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByRole = `-- name: ListUsersByRole :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE role = $1
ORDER BY created_at DESC
LIMIT $3::int
OFFSET $2::int
`

type ListUsersByRoleParams struct {
	Role   string `db:"role" json:"role"`
	Offset int32  `db:"offset" json:"offset"`
	Limit  int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListUsersByRole(ctx context.Context, arg ListUsersByRoleParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByRole, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByState = `-- name: ListUsersByState :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE state = $1
ORDER BY updated_at DESC
LIMIT $3::int
OFFSET $2::int
`

type ListUsersByStateParams struct {
	State  string `db:"state" json:"state"`
	Offset int32  `db:"offset" json:"offset"`
	Limit  int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListUsersByState(ctx context.Context, arg ListUsersByStateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByState, arg.State, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersNearLocation = `-- name: ListUsersNearLocation :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE is_blocked = FALSE
  AND location_lat IS NOT NULL
  AND location_lon IS NOT NULL
  AND ABS(location_lat - $1) <= $2
  AND ABS(location_lon - $3) <= $4
ORDER BY POWER(location_lat - $1, 2) + POWER(location_lon - $3, 2)
LIMIT $6::int
OFFSET $5::int
`

type ListUsersNearLocationParams struct {
	TargetLat pgtype.Numeric `db:"target_lat" json:"target_lat"`
	LatDelta  pgtype.Numeric `db:"lat_delta" json:"lat_delta"`
	TargetLon pgtype.Numeric `db:"target_lon" json:"target_lon"`
	LonDelta  pgtype.Numeric `db:"lon_delta" json:"lon_delta"`
	Offset    int32          `db:"offset" json:"offset"`
	Limit     int32          `db:"limit" json:"limit"`
}

func (q *Queries) ListUsersNearLocation(ctx context.Context, arg ListUsersNearLocationParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersNearLocation,
		arg.TargetLat,
		arg.LatDelta,
		arg.TargetLon,
		arg.LonDelta,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
FROM users
WHERE (username ILIKE CONCAT('%', $1, '%') OR name ILIKE CONCAT('%', $1, '%'))
ORDER BY updated_at DESC
LIMIT $3::int
OFFSET $2::int
`

type SearchUsersParams struct {
	Query  interface{} `db:"query" json:"query"`
	Offset int32       `db:"offset" json:"offset"`
	Limit  int32       `db:"limit" json:"limit"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.Query, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Role,
			&i.State,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocationLat,
			&i.LocationLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unblockUser = `-- name: UnblockUser :exec
UPDATE users
SET
    is_blocked = FALSE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UnblockUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, unblockUser, id)
	return err
}

const updateUserLocation = `-- name: UpdateUserLocation :one
UPDATE users
SET
    location_lat = $1,
    location_lon = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type UpdateUserLocationParams struct {
	LocationLat pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon pgtype.Numeric `db:"location_lon" json:"location_lon"`
	ID          int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateUserLocation(ctx context.Context, arg UpdateUserLocationParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserLocation, arg.LocationLat, arg.LocationLon, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET
    username = $1,
    name = $2,
    updated_at = NOW()
WHERE id = $3
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type UpdateUserProfileParams struct {
	Username pgtype.Text `db:"username" json:"username"`
	Name     string      `db:"name" json:"name"`
	ID       int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile, arg.Username, arg.Name, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET
    role = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type UpdateUserRoleParams struct {
	Role string `db:"role" json:"role"`
	ID   int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const updateUserState = `-- name: UpdateUserState :one
UPDATE users
SET
    state = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type UpdateUserStateParams struct {
	State string `db:"state" json:"state"`
	ID    int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateUserState(ctx context.Context, arg UpdateUserStateParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserState, arg.State, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (
    id,
    username,
    name,
    role,
    state,
    is_blocked,
    location_lat,
    location_lon
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, false),
    $7,
    $8
)
ON CONFLICT (id) DO UPDATE
SET
    username = EXCLUDED.username,
    name = EXCLUDED.name,
    role = EXCLUDED.role,
    state = EXCLUDED.state,
    is_blocked = EXCLUDED.is_blocked,
    location_lat = EXCLUDED.location_lat,
    location_lon = EXCLUDED.location_lon,
    updated_at = NOW()
RETURNING id, username, name, role, state, is_blocked, created_at, updated_at, location_lat, location_lon
`

type UpsertUserParams struct {
	ID          int64          `db:"id" json:"id"`
	Username    pgtype.Text    `db:"username" json:"username"`
	Name        string         `db:"name" json:"name"`
	Role        string         `db:"role" json:"role"`
	State       string         `db:"state" json:"state"`
	IsBlocked   interface{}    `db:"is_blocked" json:"is_blocked"`
	LocationLat pgtype.Numeric `db:"location_lat" json:"location_lat"`
	LocationLon pgtype.Numeric `db:"location_lon" json:"location_lon"`
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.ID,
		arg.Username,
		arg.Name,
		arg.Role,
		arg.State,
		arg.IsBlocked,
		arg.LocationLat,
		arg.LocationLon,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Role,
		&i.State,
		&i.IsBlocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationLat,
		&i.LocationLon,
	)
	return i, err
}
